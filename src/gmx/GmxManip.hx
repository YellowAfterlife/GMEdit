package gmx;
import electron.Dialog;
import electron.FileSystem;
import electron.FileWrap;
import gml.Project;
import haxe.io.Path;
import js.lib.RegExp;
import js.html.Element;
import js.html.Console;
import ui.ChromeTabs;
import ui.treeview.TreeView;
import ui.treeview.TreeViewItemMenus;
import parsers.GmlSeeker;
import gml.file.GmlFile;
import file.kind.gmx.*;
import file.kind.gml.*;
using tools.NativeArray;

/**
 * ...
 * @author YellowAfterlife
 */
class GmxManip {
	static function resolve(q:TreeViewItemBase, ?root:SfGmx) {
		if (q.chain.length > 0) {
			q.chain[0] = q.chain[0].toLowerCase();
		} else q.last = q.last.toLowerCase();
		var pj = Project.current;
		q.pj = pj;
		if (root == null) root = pj.readGmxFileSync(pj.name);
		var plural = q.plural, single = q.single;
		//
		var dir = root;
		for (sp in q.chain) {
			var sub = null;
			for (o in dir.findAll(plural)) {
				if (o.get("name") == sp) {
					sub = o;
					break;
				}
			}
			if (sub == null) {
				Dialog.showAlert("Couldn't find directory " + q.chain.join("/"));
				return null;
			} else dir = sub;
		}
		//
		var ref:SfGmx = null;
		var rxn = new RegExp("^\\w+[/\\\\](\\w+)");
		for (o in dir.children) {
			if (o.name == single) {
				var r = rxn.exec(o.text);
				if (r != null && r[1] == q.last) {
					ref = o; break;
				}
			} else if (o.get("name") == q.last) {
				ref = o; break;
			}
		}
		if (ref == null) {
			Dialog.showAlert("Couldn't find item " + q.last + "!");
			return null;
		}
		return {
			pj: pj,
			root: root,
			plural: plural,
			single: single,
			dir: dir,
			ref: ref,
		};
	}
	public static function add(q:TreeViewItemCreate) {
		var d = resolve(q);
		if (d == null) return false;
		var pj = d.pj;
		var root = d.root;
		var plural = d.plural;
		var single = d.single;
		var dir = d.dir;
		var ref = d.ref;
		//
		var name = q.name;
		var ngmx:SfGmx;
		if (q.mkdir) {
			ngmx = new SfGmx(plural);
			ngmx.set("name", name);
		} else {
			var ntxt:String = switch (single) {
				case "script": plural + "\\" + name + ".gml";
				case "shader": plural + "\\" + name + ".shader";
				default: plural + "\\" + name;
			};
			switch (single) {
				case "script": {
					q.npath = '$plural/$name.gml';
					var gml = q.gmlCode;
					if (gml == null) gml = '/// $name';
					pj.writeTextFileSync(q.npath, gml);
					GmlSeeker.runSync(pj.fullPath(q.npath), gml, q.name, KGmlScript.inst);
					GmlFile.open(q.name, pj.fullPath(q.npath));
				};
				case "object": {
					q.npath = '$plural/$name.object.gmx';
					//{ pasted template
					var tpl = '<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events/>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
';
					//}
					pj.writeTextFileSync(q.npath, tpl);
					GmlSeeker.runSync(pj.fullPath(q.npath), tpl, q.name, KGmxEvents.inst);
					GmlFile.open(q.name, pj.fullPath(q.npath));
				};
				case "shader": {
					q.npath = '$plural/$name.shader';
					var tmp = '//
// Simple passthrough vertex shader
//
attribute vec3 in_Position;                  // (x,y,z)
//attribute vec3 in_Normal;                  // (x,y,z)     unused in this shader.	
attribute vec4 in_Colour;                    // (r,g,b,a)
attribute vec2 in_TextureCoord;              // (u,v)

varying vec2 v_vTexcoord;
varying vec4 v_vColour;

void main()
{
    vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);
    gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;
    
    v_vColour = in_Colour;
    v_vTexcoord = in_TextureCoord;
}

//######################_==_YOYO_SHADER_MARKER_==_######################@~//
// Simple passthrough fragment shader
//
varying vec2 v_vTexcoord;
varying vec4 v_vColour;

void main()
{
    gl_FragColor = v_vColour * texture2D( gm_BaseTexture, v_vTexcoord );
}

';
					pj.writeTextFileSync(q.npath, tmp);
					GmlFile.open(q.name, pj.fullPath(q.npath));
				}
			}
			ngmx = new SfGmx(single, ntxt);
		}
		//
		switch (q.order) {
			case -1: {
				dir.children.insert(dir.children.indexOf(ref), ngmx);
			};
			case 1: {
				dir.children.insert(dir.children.indexOf(ref) + 1, ngmx);
			};
			default: {
				ref.children.push(ngmx);
			};
		}
		TreeViewItemMenus.createImplTV(q);
		//
		pj.writeTextFileSync(pj.name, root.toGmxString());
		pj.reload();
		return true;
	}
	public static function remove(q:TreeViewItemBase) {
		var d = resolve(q);
		if (d == null) return false;
		var pj = d.pj;
		var root = d.root;
		var plural = d.plural;
		var single = d.single;
		var dir = d.dir;
		var ref = d.ref;
		//
		function remrec(node:SfGmx):Void {
			if (node.name == single) {
				var dp = node.text;
				var isScript = single == "script";
				if (!isScript) dp += '.$single.gmx';
				if (pj.existsSync(dp)) {
					pj.unlinkSync(dp);
					var fp = pj.fullPath(dp);
					if (ui.Preferences.current.closeTabsOnFileDeletion)
					for (tab in ChromeTabs.impl.tabEls){
						if (tab.gmlFile.path == null) continue;
						if (tab.gmlFile.path == fp) {
							tab.closeButton.click();
							break;
						}
					}
				}
			} else {
				for (child in node.children) remrec(child);
			}
		}
		//
		remrec(ref);
		dir.removeChild(ref);
		q.tvDir.treeItems.removeChild(q.tvRef);
		//
		pj.writeTextFileSync(pj.name, root.toGmxString());
		pj.reload();
		return true;
	}
	public static function rename(q:TreeViewItemRename) {
		var d = resolve(q);
		if (d == null) return false;
		var pj = d.pj;
		var single = d.single;
		var gmx = d.ref;
		if (gmx.name != single) {
			gmx.set("name", q.name);
		} else {
			var p0 = gmx.text;
			switch (single) {
				case "script", "object": {};
				default: p0 += '.$single.gmx';
			}
			var mt = new RegExp("^(\\w+[/\\\\])(\\w+)(.*)$").exec(p0);
			if (mt == null) {
				Dialog.showAlert("Can't match resource name");
				return false;
			}
			var p1 = mt[1] + q.name + mt[3];
			//
			var fp0 = pj.fullPath(p0);
			var fp1 = pj.fullPath(p1);
			for (tab in ChromeTabs.impl.tabEls){
				if (tab.gmlFile.path != fp0) continue;
				tab.gmlFile.path = fp1;
				tab.tabText = q.name;
				tab.setAttribute(ChromeTabs.attrContext, fp1);
				break;
			}
			//
			pj.renameSync(p0, p1);
			gmx.text = p1;
		}
		TreeViewItemMenus.renameImpl_1(q);
		pj.writeTextFileSync(pj.name, d.root.toGmxString());
		pj.reload();
		return true;
	}
	public static function move(q:TreeViewItemMove) {
		var d = resolve(q);
		if (d == null) return false;
		q.chain = q.srcChain;
		q.last = q.srcLast;
		var sd = resolve(q, d.root);
		if (sd == null) return false;
		sd.dir.children.remove(sd.ref);
		switch (q.order) {
			case 1: d.dir.children.insertAfter(sd.ref, d.ref);
			case -1: d.dir.children.insertBefore(sd.ref, d.ref);
			default: d.ref.children.push(sd.ref);
		}
		d.pj.writeTextFileSync(d.pj.name, d.root.toGmxString());
		yy.YyManip.moveTV(q);
		return true;
	}
	public static function addExtensionFile(extensionPath:String, filePaths:Array<String>) {
		var ext = FileWrap.readGmxFileSync(extensionPath);
		var extDir = Path.directory(extensionPath);
		var changed = false;
		var extFileRoot = ext.find("files");
		var extFiles = extFileRoot.findAll("file");
		var firstFile = extFiles[0];
		var firstFileConfigs = firstFile != null ? firstFile.find("ConfigOptions").findAll("Config") : null;
		for (srcFull in filePaths) {
			var rel = Path.withoutDirectory(srcFull);
			var dstFull = extDir + "/" + rel;
			
			try {
				FileSystem.copyFileSync(srcFull, dstFull);
			} catch (x:Dynamic) {
				Console.error(x);
			}
			
			var ref = extFiles.findFirst(function(file) {
				return file.findText("filename") == rel;
			});
			if (ref != null) {
				// trying to add the file that's already here?
				if (Path.normalize(srcFull) == Path.normalize(dstFull)) continue;
				continue;
			}
			
			var file = extFileRoot.addTextChild("file");
			file.addTextChild("filename", rel);
			file.addTextChild("origname", "extensions\\" + rel);
			file.addTextChild("init", "");
			file.addTextChild("final", "");
			file.addTextChild("kind", "" + yy.YyExtension.YyExtensionFileKind.detect(srcFull));
			file.addTextChild("uncompress", "0");
			var configOptions = file.addTextChild("ConfigOptions", null);
			if (firstFileConfigs != null) {
				for (oldConfig in firstFileConfigs) {
					var config = configOptions.addTextChild("Config", null);
					config.set("name", oldConfig.get("name"));
					config.addTextChild("CopyToMask", "9223372036854775807");
				}
			} else {
				var config = configOptions.addTextChild("Config", null);
				config.set("name", "Default");
				config.addTextChild("CopyToMask", "9223372036854775807");
			}
			file.addTextChild("ProxyFiles");
			file.addTextChild("functions");
			file.addTextChild("constants");
			changed = true;
		}
		if (changed) {
			FileWrap.writeGmxFileSync(extensionPath, ext);
			Project.current.reload();
		}
	}
}
